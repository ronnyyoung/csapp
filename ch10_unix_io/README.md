# 系统级I/O

//TODO
听关于[Linux系统编程-IO的课](www.watchmen.cn/video/linux)

输入/输出（I/O）是在主存和外部设备（例如磁盘驱动器、终端和网络）之间复制数据的过程。

- 输入：从I/O设备复制数据到主存
- 输出：从主存复制数据到I/O设备

//TDO 补充IO的示意图

几乎所有编程语言都提供了执行I/O的较高级的工具（函数或类）。在ANSI C的标准库中提供了标准I/O库，包含像printf和scanf这样执行带缓冲区的I/O函数。C++语言用它的重载操作符<<（输入）和>>（输出）提供了类似的功能，并把I/O抽象成了流的概念，非常的形象。无疑，所有这些高级别的I/O库在Linux下都是通过Linux内核提供的底层I/O函数来完成的。

在大多数的时候，用那些编程语言提供的I/O库已经满足我们大多数的应用需求了，为什么我们还要去学习系统底层的I/O呢？
- 理解系统级的I/O有助于我们理解其他操作系统的概念，比如理解进程的创建与执行，多进程之间文件共享，虚拟内存概念等。
- 有时候我们需要一些功能，程序语言提供的I/O库可能不能满足。比如C/C++的标准I/O库就没有读取文件元数据（文件大小、创建时间等）的相关接口。

## 1. I/O的基本操作

一个Linux文件就是m个字节的序列：

$$B_0,B_1,\cdots,B_k,\cdots,B_{m-1}$$

所有的I/O设备在Linux中都被模型化为文件，所有内存与这些设备之间的数据传递与当作相应的文件的读和写。这是Unix引入的一种优雅的设计哲学，可以使得所有对I/O设备的输入和输出都能以一种统一且一致的方式来执行。大致说来的操作概括为以下几种：
- `打开文件`。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备。内核返回一个小的非负数，叫描述符，也叫文件句柄，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只用记住这个描述符。Linux shell创建的每个进程开始时都会打开三个文件：标准输入(STDIN_FILENO=0)，标准输出(STDIN_FILENO=1)，标准错误（STDIN_FILENO=2）。
- `改变文件的操作位置`。对于已经打开的文件，内核都记录着一个文件位置k，初始值为0，它是从文件开头起始的字节偏移量。应用程序能够通过执行seek操作，显式地设置文件的当前位置为k。
- 读写文件。一个读操作就是从文件复制$n>0$个字节到内存，从当前文件位置k开始，然后k增加到k+n。给定一个大小为m字节的文件，当$k\ge m$时，也就是读到了文件结尾时，执行读操作会触发一个称为end-of-file(EOF)的操作，应用程序能检测到这个条件（通过判断read函数的返回值）。类似地，写操作就是从内存复制n>0个字节到一个文件，从当前文件位置k开始，然后更新k。
- `关闭文件`。当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论这个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。//TODO 理解多个进程同时打开一个文件时，一个进程结束时，操作系统内核对文件的处理。

## 2. 文件

每个Linux文件都有一个类型(type)来表明它在系统中的角色：

- 普通文件。应用程序通常会区分文本文件和二进制文件，对内核而言，文本文件和二进制文件没有区别。文本文件可以看成是一个`文本行`序列。
- 目录。它是一个包含了一组链接的文件。//TODO，如何理解目录文件，它的内容是否可读。二进制序列是什么。
- 套接字。socket是用来与另一个进程进行跨网络通信的文件。

其他的文件类型包含：命名管道，符号链接，字符块设备。

每个进程都有一个环境变量：在shell中运行进程时的`当前工作目录`。有了当前目录的概念，在进程中就可以使用一些相对路径。

所有Linux下的文件都可以通过一个绝对路径或相对路径来标识，所以我们一般要打开文件时，就将该文件的路径告诉内核。

## 3. 打开和关闭文件

进程是通过调用`open`函数来打开一个已经存在的文件或创建一个新的文件。

```cpp
/// @brief 打开一个文件
/// @param[in] filename 要打开的文件的位置
/// @param[in] flags 指明了进程打算如何访问这个文件，读写模式
/// @param[in] mode 指定新的文件的访问权限位，设置为0时，继承了当前进程的权限
/// @retun 返回新的文件描述符，返回的文件描述符总是在进程中当前没有打开的最小描述符
/// @note 如何打开文件失败，则返回-1
int open(char *filename, int flags, mode_t mode);
```
//TODO 详细了解进程的权限与umask

通过调用`colse`函数关闭一个打开的文件，关闭一个已经关闭的描述符，则返回-1。

```cpp
#include <unistd.h>

/// @brief 关闭一个打开的文件描述符
/// @param[in] fd 文件描述符
/// @return 若成功则返加0，若出错则为-1
int close(int fd);
```

## 4. 读与写文件

我们可以使用`read`和`write`函数来对文件进行读写

```cpp
/// @brief 从文件中读取不超过n个字节到buf中
/// @param[in] fd 要读的文件的描述符
/// @param[out] buf 用于存储读到的字节
/// @param[in] n 要读取的字节数，但实际可能读取到的字节小于n
/// @return 返回实际读取到的字节数，若读到了文件结尾，则返回0，遇到错误则返回-1
ssize_t read(int fd, void *buf, size_t n);

/// @brief 从内存buf位置复制最多n个字节到描述符fd绑定的文件
/// @param[in] fd 要写的文件的文件描述符
/// @param[in] buf 写的数据在内在中的位置
/// @param[in] n 要写的字节数，其实往文件中写入的字节数可能小于n
/// @return 返回实际写到文件中的字节数，遇到错误时返回-1
ssize_t write(int fd, const void *buf, size_t n);
```

> `size_t`和`ssize_t`：`ssize_t`是有符号的，因为`read`和`write`的返回值有可能为-1

什么情况下`read`或`write`传送的字节数会比应用程序要求的要少呢。这些情况下，并不表示有错误。

- 读的时候遇到了EOF>
- 从终端读取。当我们把标准输入当文件打开时，一次最多只能读取到一行输入，当这一行输入的字节数少于调用时想要读入的字节数时。
- 读和写网络套接字。如果打开的文件对应于网络套接字，那么内部缓冲约束和较长的网络延迟会引起read和write返回不足值。对Linux管道调用`read`和`write`时，也有可能出现不足值。

在对磁盘文件进行读写时，除了EOF，我们是不会遇到实际传送与要求传递不一致的情况的。

## 5. 使用ROI包健壮地读写

ROI(Robust I/O)是一个健壮的I/O包，它会自动为我们处理`read`和`write`在进行文件读写时遇到的不足值。尤其是在网络程序中，容易出现读写不足，ROI包提供了方便、健壮和高效的I/O。RIO提供了两类不同的函数。

- 无缓冲的输入输出函数。这些函数直接在内在和文件之间传送数据，没有应用级缓冲。
- 带缓冲的输入函数。这些函数允许我们高效地从文件中读取文本行和二进制数据，这些文件的内容缓冲在应用级缓冲区内，类似于为printf这样的标准I/O函数提供的缓冲区。而且带缓冲区的RIO输入函数是线程安全的，它在同一个描述符上可以被交错地调用（打开一个文件两次，获取两个文件描述符）。

### 不带缓冲的输入，输出函数

```cpp
ssize_t rio_readn(int fd, void *usrbuf, size_t n);
ssize_t rio_writen(int fd, void *usrbuf, size_t n);
```
- [roi_readn](../csapp.c#738)：从文件描述符fd的当前文件位置最多传送n个字节到内存位置usrbuf, 除了读文件时遇到EOF，会返回一个不足值，其他情况下均不会。
- [roi_writen](../csapp.c#764)：从内存位置usrbuf传送n个字节到描述符fd，决不会返回不足值。

两者若在读写时，出错，则均返回-1。

### 带缓冲的输入函数

```cpp
#define RIO_BUFSIZE 8192
typedef struct {
    int rio_fd;                /* Descriptor for this internal buf */
    int rio_cnt;               /* Unread bytes in internal buf */
    char *rio_bufptr;          /* Next unread byte in internal buf */
    char rio_buf[RIO_BUFSIZE]; /* Internal buffer */
} rio_t;

void rio_readinitb(rio_t *rp, int fd); 
ssize_t	rio_readnb(rio_t *rp, void *usrbuf, size_t n);
ssize_t	rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen);
```

为什么要带缓冲区：假设我们要编写一个程序来计算文本文件行的数量，该如何实现呢？一种方法就是用read函数来一次一个字节地从文件传送到用户内在，检查每个字节来查找换行符。这个方法的缺点就是效率不高，每读取文件中的一个字节都要陷入内核。另外一个方法，就是我们一次从文件中读取一个固定大小（BUF_SIZE）的字符，然后再从这个buffer里一个一个的读取字符进行判断是否是换行符，当这个buffer被处理完后，我们再从文件中读取BUF_SIZE个字节到buffer中。

后面一种处理方法就是带缓冲的输入，[roi_readnb](../csapp.c#838)就是一个这样的带缓冲区的版本。如果我们处理的是文本，一次需要读取一行，那可以直接使用[roi_readlineb](../csapp.c#860)。它从一个内部缓冲区中一次复制一行，当缓冲区变空时，内部会自动的调用read进行重填。

调用带缓冲区的读函数时，我们需要先调用[roi_readinitb](../csapp.c#826)来将一个缓冲区与一个文件描述符进行绑定。


