# 并发编程 

我们把程序中在时间上有重叠的**逻辑控制流**称为**并发**。注意这里特别的指逻辑上的控制流，而不是实际CPU执行的指令流。

之前我们看到的并发现象，都是基于进程的，内核提供了同时运行多个进程的机制。实际上，并发在应用程序内部也扮演着重要的角度，例如以下的场景：

- 访问慢速I/O设备。当应用程序在等待来自慢速I/O设备（例如磁盘）的数据到达时，内核会运行其他进程，使CPU保持繁忙。每个应用都可以按照类似的方式，通过交替执行I/O请求和其他有用的工作来利用并发。
- 与人交互。现代操作系统的窗口程序，在响应人的一些动作：鼠标点击，拖动时，一般都是通过一个独立的并发逻辑流来执行这个操作。
- 通过推迟工作以降低延迟。也就是说,把一些不紧急活，留下CPU空闲的时候再做。比如动态内存回收时的合并操作。
- 服务多个网络客户端。我们可以利用并发的特性，让我们在第11章中介绍的服务器可以同时处理多个客户端连接请求，它可以为每个客户端创建一个独立的并发逻辑流来响应对应的客户端。
- 在多核机器上进行并行计算。利用并发程序，可以把多个CPU利用起来，让程序执行的更快。

现代操作系统一般提供下面三种方法来构造并发程序。
1. 进程。用这种方法，每个逻辑控制流都是一个进程，由内核来调度和维护。因为进程有独立的虚拟地址空间（安全性高），想要和其他流通信，控制流必须使用某种显式的进程间通信（IPC）机制（通信麻烦且代价高）。
2. I/O多路复用。这种形式的并发编程中，应用程序在一个进程的上下文中显示地调度它们自己的逻辑流。逻辑流被模型化为状态机，数据到达文件描述符后，主进程显式地从一个状态转换到另一个状态。因为程序是一个单独的进程，所以所有的流都共享一个地址空间。
3. 线程。线程是运行在一个单一进程上下文中的逻辑流，由内核进行调度。线程有上面两者的一些特点，它像内进流一样由内核进行调度，而像I/O多路复用流一样共享同一个虚拟地址空间。

I/O多路复用操作起来像是在进程内部自己维护了了多个任务，根据任务的状态，在多个任务之间来回的切换执行。这有些像是一个用户级的多线程实现。只是对于I/O多路复用来说，需要记录的状态信息比较少，比线程模型要简单高效很多。I/O多路复用虽然很高效，但是它只能利用单核的性能。

在本章中，将会研究上面三种并发技术。

# 1. 基于进程的并发编程 

当服务端`Accept`新的连接请求时，就会新建一个连接描述符来处理这个连接，同时创建一个子进程，在子进程内部来处理对这个客户端的响应。

这里需要注意的就是，子进程会复制父进程的套接字描述符`listenfd`和`connfd`（实际上子进程会拷贝父进程的整个文件描述符表）。我们要合理的关闭它们来保证没有内存泄漏。

- 父进程必须关闭已连接描述符。
- 子进程应该关闭监听描述符。（虽然不关闭也没事，子进程退出时，会自动清理）。

由于服务器会运行很长时间中，所以我们必须要包括一个SIGCHLD处理程序，来回收僵死子进程的资源。而且因为当SIGCHILD处理程序执行时，SIGCHLD信号是阻塞的，而Linux信号是不排队的，所以SIGCHLD处理程序必须准备好回收多个僵死子进程资源。

> **进程的回收：** 当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程，从此时开始，该进程就不存在了。一个终止了但还未被回收的进程称为僵死进程(zombie)。
>
> 如果一个父进程终止了，内核会安排init进程成为它的孤儿进程的养父。init进程的PID为1,是在系统启动时由内核创建的，它不会终止，是所有进程的祖先。如果父进程没有回收它的僵死子进程就终止了，那么内核会安排init进程去回收它们。
>
> 由于服务器程序一般都长时间运行，所以我们应该主动的回收它们的僵死子进程。即使子进程没有运行，它们仍然消耗系统的内存资源。

```cpp
void echo(int connfd);

void sigchld_handler(int sig) {
    while(waitpid(-1, 0, WNOHANG) > 0)
        ;
    return;
}

int main(int argc, char *argv[]) {
    int listenfd, connfd;
    socklen_t clientfd_len;
    struct sockaddr_storage clientaddr;

    // 注册SIGCHLD信号的处理函数
    Signal(SIGCHLD, sigchld_handler);

    listenfd = Open_listenfd(argv[1]);
    while(1) {
        clientfd_len = sizeof(struct sockaddr_stroage);
        connfd = Accept(listenfd, (SA *)&clientaddr, &clientfd_len);
        if (Fork() == 0) {
            Close(listenfd);
            echo(connfd);
            Close(connfd);
            exit(0);
        }
        Close(connfd);
    }
}
```
进程并发的优劣：父子进程间虽然共享文件表，但不共享地址空间，所以如果父子进程要进行其他数据的传递，往往需要一些IPC的途径，比较慢。然而，正是由于进程独立的地址空间，这样保证了父进程的进程空间不会被子进程破坏。

# 2. 基于I/O多路复用的并发编程

下面我们来介绍基于I/O多路复用的并发编程。上一小节我们讨论了使用多进程的技术来并发的处理多个客户端的请求。我们并发的部分实际上是处理的部分。只是我们收到一个客户端的请求后，可以立即用子进程去处理，主进程返回了，立马去监听下一个连接请求了。

我们知道当我们在处理一个客户端的请求时，往往是交互式的，当我们给客户端一定的响应后，我们不能立即返回，而是等待客户端的下一条请求。 那么在这个间隙，我们能不能充分利用起来。在发送响应消息后，我们等待这个客户端请求的同时，也能够能其他客户端的请求做出响应。 如果我们能够等待的间隙上，多处理了另外一个客户端的请求，那整个服务器的处理效率就高了起来。

如果只利用我们之前学习到的一些函数，这是做不到的，因为我们在服务端使用的`read/write`等都是阻塞式的I/O。当我们调用`read`等客户端的下一条消息时，当前的进程就被挂起了，直到收到数据为止。

操作系统为我们提供了非阻塞的I/O模型，通过调用fcntl（POSIX）或ioctl（UNix)设为非阻塞模式，这时，当我们调用read时，如果有数据收到，就返回数据，如果没有数据收到，就立即返回一个错误。

这样我们就可以在`read`返回错误后，去处理其他的连接请求了。所以我们的直观想法是，我们可以同时建立起多个与客户端的连接，然后循环的调用`read`来检查当前的连接有没有要处理的消息，有就处理，没有就返回。
