# 并发编程 拱顶

我们把程序中在时间上有重叠的**逻辑控制流**称为**并发**。注意这里特别的指逻辑上的控制流，而不是实际CPU执行的指令流。

之前我们看到的并发现象，都是基于进程的，内核提供了同时运行多个进程的机制。实际上，并发在应用程序内部也扮演着重要的角度，例如以下的场景：

- 访问慢速I/O设备。当应用程序在等待来自慢速I/O设备（例如磁盘）的数据到达时，内核会运行其他进程，使CPU保持繁忙。每个应用都可以按照类似的方式，通过交替执行I/O请求和其他有用的工作来利用并发。
- 与人交互。现代操作系统的窗口程序，在响应人的一些动作：鼠标点击，拖动时，一般都是通过一个独立的并发逻辑流来执行这个操作。
- 通过推迟工作以降低延迟。也就是说,把一些不紧急活，留下CPU空闲的时候再做。比如动态内存回收时的合并操作。
- 服务多个网络客户端。我们可以利用并发的特性，让我们在第11章中介绍的服务器可以同时处理多个客户端连接请求，它可以为每个客户端创建一个独立的并发逻辑流来响应对应的客户端。
- 在多核机器上进行并行计算。利用并发程序，可以把多个CPU利用起来，让程序执行的更快。

现代操作系统一般提供下面三种方法来构造并发程序。
1. 进程。用这种方法，每个逻辑控制流都是一个进程，由内核来调度和维护。因为进程有独立的虚拟地址空间（安全性高），想要和其他流通信，控制流必须使用某种显式的进程间通信（IPC）机制（通信麻烦且代价高）。
2. I/O多路复用。这种形式的并发编程中，应用程序在一个进程的上下文中显示地调度它们自己的逻辑流。逻辑流被模型化为状态机，数据到达文件描述符后，主进程显式地从一个状态转换到另一个状态。因为程序是一个单独的进程，所以所有的流都共享一个地址空间。
3. 线程。线程是运行在一个单一进程上下文中的逻辑流，由内核进行调度。线程有上面两者的一些特点，它像内进流一样由内核进行调度，而像I/O多路复用流一样共享同一个虚拟地址空间。

I/O多路复用操作起来像是在进程内部自己维护了了多个任务，根据任务的状态，在多个任务之间来回的切换执行。这有些像是一个用户级的多线程实现。只是对于I/O多路复用来说，需要记录的状态信息比较少，比线程模型要简单高效很多。I/O多路复用虽然很高效，但是它只能利用单核的性能。

在本章中，将会研究上面三种并发技术。

# 1. 基于进程的并发编程 

当服务端`Accept`新的连接请求时，就会新建一个连接描述符来处理这个连接，同时创建一个子进程，在子进程内部来处理对这个客户端的响应。

这里需要注意的就是，子进程会复制父进程的套接字描述符`listenfd`和`connfd`（实际上子进程会拷贝父进程的整个文件描述符表）。我们要合理的关闭它们来保证没有内存泄漏。

- 父进程必须关闭已连接描述符。
- 子进程应该关闭监听描述符。（虽然不关闭也没事，子进程退出时，会自动清理）。

由于服务器会运行很长时间中，所以我们必须要包括一个SIGCHLD处理程序，来回收僵死子进程的资源。而且因为当SIGCHILD处理程序执行时，SIGCHLD信号是阻塞的，而Linux信号是不排队的，所以SIGCHLD处理程序必须准备好回收多个僵死子进程资源。

> **进程的回收：** 当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程，从此时开始，该进程就不存在了。一个终止了但还未被回收的进程称为僵死进程(zombie)。
>
> 如果一个父进程终止了，内核会安排init进程成为它的孤儿进程的养父。init进程的PID为1,是在系统启动时由内核创建的，它不会终止，是所有进程的祖先。如果父进程没有回收它的僵死子进程就终止了，那么内核会安排init进程去回收它们。
>
> 由于服务器程序一般都长时间运行，所以我们应该主动的回收它们的僵死子进程。即使子进程没有运行，它们仍然消耗系统的内存资源。

```cpp
void echo(int connfd);

void sigchld_handler(int sig) {
    while(waitpid(-1, 0, WNOHANG) > 0)
        ;
    return;
}

int main(int argc, char *argv[]) {
    int listenfd, connfd;
    socklen_t clientfd_len;
    struct sockaddr_storage clientaddr;

    // 注册SIGCHLD信号的处理函数
    Signal(SIGCHLD, sigchld_handler);

    listenfd = Open_listenfd(argv[1]);
    while(1) {
        clientfd_len = sizeof(struct sockaddr_stroage);
        connfd = Accept(listenfd, (SA *)&clientaddr, &clientfd_len);
        if (Fork() == 0) {
            Close(listenfd);
            echo(connfd);
            Close(connfd);
            exit(0);
        }
        Close(connfd);
    }
}
```
进程并发的优劣：父子进程间虽然共享文件表，但不共享地址空间，所以如果父子进程要进行其他数据的传递，往往需要一些IPC的途径，比较慢。然而，正是由于进程独立的地址空间，这样保证了父进程的进程空间不会被子进程破坏。

# 2. 基于I/O多路复用的并发编程

下面我们来介绍基于I/O多路复用的并发编程。上一小节我们讨论了使用多进程的技术来并发的处理多个客户端的请求。我们并发的部分实际上是处理的部分。只是我们收到一个客户端的请求后，可以立即用子进程去处理，主进程返回了，立马去监听下一个连接请求了。

我们知道当我们在处理一个客户端的请求时，往往是交互式的，当我们给客户端一定的响应后，我们不能立即返回，而是等待客户端的下一条请求。 那么在这个间隙，我们能不能充分利用起来。在发送响应消息后，我们等待这个客户端请求的同时，也能够能其他客户端的请求做出响应。 如果我们能够等待的间隙上，多处理了另外一个客户端的请求，那整个服务器的处理效率就高了起来。

如果只利用我们之前学习到的一些函数，这是做不到的，因为我们在服务端使用的`read/write`等都是阻塞式的I/O。当我们调用`read`等客户端的下一条消息时，当前的进程就被挂起了，直到收到数据为止。

操作系统为我们提供了非阻塞的I/O模型，通过调用fcntl（POSIX）或ioctl（UNix)设为非阻塞模式，这时，当我们调用read时，如果有数据收到，就返回数据，如果没有数据收到，就立即返回一个错误。

这样我们就可以在`read`返回错误后，去处理其他的连接请求了。所以我们的直观想法是，我们可以同时建立起多个与客户端的连接，建立起来一个连接描述符集合，然后循环的调用`read`来检查当前的连接有没有要处理的消息，有就处理，没有就返回。

但上面的想法存在的问题是，我们要不断的轮询。操作系统给我们提供了一些便利用的函数帮我们来处理这些复杂的流程。

逻辑上，我们将描述符集合看成一个大小为n的位向量：$b_{n-1},\cdots,b_1,b_0$。每个位$b_k$对应于描述符$k$。当且仅当$b_k=1$时，描述符k才表明是在描述符集合中的。

对于`fd_set`类型的对象，只能对其做下面三件事：
1. 分配它们
2. 将一个此种类型的变量赋值给另一个变量。
3. 用`FD_ZERO/FD_SET/FD_CLR/FD_ISSET`宏来修改它们。

```cpp
#include <sys/select.h>

/// @breif 等待一组描述符准备好读
/// @param[in] n 描述符集合的大小
/// @param[in] fdset 描述符集合
/// @return 返回准备好的描述符的个数
int select(int n, fd_set *fdset, NULL, NULL, NULL);

FD_ZERO(fd_set *fdset);                 // 清空描述符集合中所有的位
FD_CLR(int fd, fd_set *fdset);          // 将fd从描述符集合中去除
FD_SET(int fd, fd_set *fdset);          // 将fd添加到描述符集合中
FD_ISSET(int fd, fd_set *fdset);        // 判断fd是否在描述符集合中
```
`select`函数会一直阻塞，直到读集合(fdset)中至少有一个描述符准备好可以读。描述符可读取意思是从该描述符中可以读取到字节，不会阻塞（阻塞式IO）或返回错误（非阻塞式IO）。

`select`有个副作用，会它修改传进去的fdset，修改后的fdset指明了一个准备好的集合，这个集合则由读集合中准备好的描述符组成的。所以每次我们调用`select`都传入一个读集合的副本。

## 2.1 基于I/O多路复用的并发事件驱动服务器

按我们上面讨论的思想，服务端在为一个客户端连接服务时，会有消息来回的交互，我们希望利用这个交互之间的空间。那么我们并发行为的最小粒度就是，服务端响应客户端一次消息。对于echo服务器来说，就是一次每次只读取一行消息，并写回客户端，然后就再去处理其他已经准备好的描述符。

[为什么会出现IO多路复用?](
https://www.zhihu.com/question/32163005/answer/55772739)

```cpp
typedef struct {
    int maxfd;
    fd_set read_set;
    fd_set ready_set;
    int nready;
    int maxi;
    int clientfd[FD_SETSIZE];
    rio_t clientrio[FD_SETSIZE];
} pool;
```
1. 我们需要维护一个客户端连接描述符池子，每次有一个新的客户端连接时，就需要加到池子中，当服务完这个客户端时，就把它的描述符从池子中删除。`int clientfd[FD_SETSIZE]`
2. 一个读集合：`fd_set read_set`。
3. 一个准备好可读集合：`fd_set ready_set`，它在调用`select`前是读集合的副本，调用后，就返回的是就绪的描述符集合。
4. `int maxfd`指明了现在读集合中最大的描述符，也就是`select`的第一个参数，它通过与每次建立新的客户端连接返回的已连接描述符connfd比较。
5. `int maxi`指明了客户端已连接描述符池子(`clientfd[]`)中，最大的序号。避免，每次需要检测`clientfd[]`中的每个元素。
6. `select`返回的准备好集合中，可能有多个准备好读的描述符，用`nready`来计数。

开始时，我们需要初这个pool进行初始化。注意开始时，我们已经有监听描述符了，我们需要把它加到读集合，用来监听新的客户端连接请求。
```cpp
void init_pool(int listenfd, pool* p) {
    p->maxi = -1;
    // 将开始时每个客户端连接描述符设置为-1,表示客户端连接池子为空
    for (int i = 0; i < FD_SETSIZE; i++) {
        p->clientfd[i] = -1;
    }
    p->maxfd = listenfd;
    FD_ZERO(&p->read_set);
    FD_SET(listenfd, &p->read_set);
}
```

当我们调用`select`，发现`listenfd`描述符有响应时，说明是新的客户端连接，这时，我们需要将新的客户端连接描述符加到池子中。

```cpp
void add_client(int connfd, pool *p) {
    p->nready--; // 因为已经把Listenfd的响应处理掉了。
    for (int i = 0; i < FD_SETSIZE; i++) {
        // 从头开始，找到一个空的slot来存放新的connfd
        if (p->clientfd[i] >=0 ) {
            continue;
        }
        p->clientfd[i] = connfd;
        Rio_readinitb(&p->clientrio[i], connfd);
        // 新的connfd加到读集合中
        FD_SET(connfd, &p->read_set);
        // 更新发现的最大的描述符
        if (connfd > p->maxfd) {
            p->maxfd = connfd;
        }
        // 更新客户端连接符池子中最大的水位
        if (i > p->maxfd) {
            p->maxi = i;
        }
        // 如果客户端连接描述符池子满了，就返回错误。
        if (i == FD_SETSIZE) {
            app_error("add_client error: Too many clients");
        }
    }
}
```

## 2.2 基于I/O多路复用的并发服务器的优劣：

优点：没有任务进程、线程调度引起的上下文切换的代价消耗，执行起来非常快，整个执行流实际是顺序的，容易调试。

缺点是：编码复杂，尤其是控制逻辑粒度较低时。在上面的例子中，我们的粒度是服务端每次响应一行客户端的消息。当我们的服务器在执行读取一个文件行时，其他逻辑流就不可能有机会执行。这就很容易受到某些客户端恶意只发送一行文本行就停止的行为攻击。如果我们还要响应不同的客户端连接优先级，我们就需要加入更复杂的控制逻辑了。

# 3. 基于线程的并发编程

线程(thread)就是运行在进程上下文中的逻辑流。现代的操作系统几乎都允许我们在一个进程里同时运行多个线程，同时执行多个逻辑流，CPU基于线程来进行调度，而不是基于进程。

每个线程都有它自己的线程上下文(thread context)，包括一个唯一的整数线程ID、栈、栈指针、程序计数器、通用目的寄存器和条件码。但是所有运行在一个进程中的线程共享该进程的整个虚拟地址空间。

所以基于线程的并发程序有点像把上面介绍的进程与I/O多路复用的特点进行结合：1）线程的调用是内核自动调度的。2）同基于I/O多路复用一样，多个线程运行在单一的进程上下文中，共享这个进程的虚拟地址空间，包括代码、数据、堆、共享库和打开的文件。

 在一个进程刚开始运行时，只有一个线程，我们称为主线程。通过一些系统调用，我们可以创建一个对等线程(peer thread)。从这里开始，两个线程就并发地运行。在单核系统上，交替执行，在多核系统上可能并行执行。
 
 进程的上下文比进程简单，所以切换时来快得多。另外线程之间的关系不像进程那样有父子层次结构。线程之间往往是对等的。

 ## Posix线程
 
 Poxsix线程(Pthreads)是在C程序中处理线程的一个标准接口。在所有Linux系统上都可用。Pthreads定义了大约60个函数，支持在进程中创建、杀死、回收线程，与对等线程安全地共享数据（锁），还可以通知对等线程系统状态的变化（条件变量）。

 下面是使用多线程的一个简单的示例程序，主线程调用`pthread_create`创建了一个对等线程，然后等待线程结束。

```cpp
void *hello(void *vargp) {
    printf("hello, world\n");
}

int main(int argc, char *argv[]) {
    pthread_t tid;
    Pthread_create(&tid, NULL, hello, NULL);
    Pthread_join(tid, NULL);

    return 0;
}
```

下面我们看一下Threads中常见的API。

```cpp
#include <pthread.h>

// 创建线程
typedef void *(func)(void *);
int pthread_create(pthread_t *tid, pthread_attr_t *attr,
                   func *f, void*arg);

// 线程内部获取本线程的线程id
pthread_t pthread_self(void)

// 线程退出
void pthread_exit(void *thread_return);

// 终止线程
int pthread_cancal(pthread_t tid);

// 回归已经终止的线程的资源
int pthread_join(pthread_t tid, void **thread_return);

// 分享线程
int pthread_detach(pthread_t tid);

// 初始化线程
pthread_once_t once_control = PTHREAD_ONCE_INIT;
int ptrhead_once(pthread_once_t *once_control, void (*init_routine)(void));
```
